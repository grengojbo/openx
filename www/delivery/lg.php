<?php

/*
+---------------------------------------------------------------------------+
| OpenX v${RELEASE_MAJOR_MINOR}                                                                |
| =======${RELEASE_MAJOR_MINOR_DOUBLE_UNDERLINE}                                                                |
|                                                                           |
| Copyright (c) 2003-2008 OpenX Limited                                     |
| For contact details, see: http://www.openx.org/                           |
|                                                                           |
| This program is free software; you can redistribute it and/or modify      |
| it under the terms of the GNU General Public License as published by      |
| the Free Software Foundation; either version 2 of the License, or         |
| (at your option) any later version.                                       |
|                                                                           |
| This program is distributed in the hope that it will be useful,           |
| but WITHOUT ANY WARRANTY; without even the implied warranty of            |
| MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             |
| GNU General Public License for more details.                              |
|                                                                           |
| You should have received a copy of the GNU General Public License         |
| along with this program; if not, write to the Free Software               |
| Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA |
+---------------------------------------------------------------------------+
$Id$
*/

/**
 *
 * This is autogenerated merged delivery file which contains all files
 * from delivery merged into one output file.
 *
 * !!!Warning!!!
 *
 * Do not edit this file. If you need to do any changes to any delivery PHP file
 * checkout sourcecode from the svn repository, do a necessary changes inside
 * "delivery_dev" folder and regenerate delivery files using command:
 * # ant generate-delivery
 *
 * For more information on ant generator or if you want to check why we do this
 * check out the documentation wiki page:
 * https://developer.openx.org/wiki/OptimizationPractices#GenerateDeliveryAntTask
 *
 */

// Require the initialisation file
function parseDeliveryIniFile($configPath = null, $configFile = null, $sections = true)
{
// Set up the configuration .ini file path location
if (!$configPath) {
$configPath = MAX_PATH . '/var';
}
if ($configFile) {
$configFile = '.' . $configFile;
}
$host = getHostName();
$configFileName = $configPath . '/' . $host . $configFile . '.conf.php';
$conf = @parse_ini_file($configFileName, $sections);
if (isset($conf['realConfig'])) {
// added for backward compatibility - realConfig points to different config
$realconf = @parse_ini_file(MAX_PATH . '/var/' . $conf['realConfig'] . '.conf.php', $sections);
$conf = mergeConfigFiles($realconf, $conf);
}
if (!empty($conf)) {
return $conf;
} elseif ($configFile === '.plugin') {
// For plugins, if no configuration file is found, return the sane default values
$pluginType = basename($configPath);
$defaultConfig = MAX_PATH . '/plugins/' . $pluginType . '/default.plugin.conf.php';
$conf = @parse_ini_file($defaultConfig, $sections);
if ($conf !== false) {
// check for false here - it's possible file doesn't exist
return $conf;
}
echo "OpenX could not read the default configuration file for the {$pluginType} plugin";
exit(1);
}
// Check for a 'default.conf.php' file
$configFileName = $configPath . '/default' . $configFile . '.conf.php';
$conf = @parse_ini_file($configFileName, $sections);
if (isset($conf['realConfig'])) {
// added for backward compatibility - realConfig points to different config
$conf = @parse_ini_file(MAX_PATH . '/var/' . $conf['realConfig'] . '.conf.php', $sections);
}
if (!empty($conf)) {
return $conf;
}
// Check to ensure Max hasn't been installed
if (file_exists(MAX_PATH . '/var/INSTALLED')) {
echo "OpenX has been installed, but no configuration file was found.\n";
exit(1);
}
// Max hasn't been installed, so delivery engine can't run
echo "OpenX has not been installed yet -- please read the INSTALL.txt file.\n";
exit(1);
}
if (!function_exists('mergeConfigFiles'))
{
function mergeConfigFiles($realConfig, $fakeConfig)
{
//unset($fakeConfig['realConfig']);
foreach ($fakeConfig as $key => $value) {
if (is_array($value)) {
if (!isset($realConfig[$key])) {
$realConfig[$key] = array();
}
$realConfig[$key] = mergeConfigFiles($realConfig[$key], $value);
} else {
if (isset($realConfig[$key]) && is_array($realConfig[$key])) {
$realConfig[$key][0] = $value;
} else {
if (isset($realConfig) && !is_array($realConfig)) {
$temp = $realConfig;
$realConfig = array();
$realConfig[0] = $temp;
}
$realConfig[$key] = $value;
}
}
}
return $realConfig;
}
}
function setupConfigVariables()
{
$GLOBALS['_MAX']['MAX_DELIVERY_MULTIPLE_DELIMITER'] = '|';
$GLOBALS['_MAX']['MAX_COOKIELESS_PREFIX'] = '__';
// Set the URL access mechanism
if (!empty($GLOBALS['_MAX']['CONF']['openads']['requireSSL'])) {
$GLOBALS['_MAX']['HTTP'] = 'https://';
} else {
if (isset($_SERVER['SERVER_PORT'])) {
if (isset($GLOBALS['_MAX']['CONF']['openads']['sslPort'])
&& $_SERVER['SERVER_PORT'] == $GLOBALS['_MAX']['CONF']['openads']['sslPort'])
{
$GLOBALS['_MAX']['HTTP'] = 'https://';
} else {
$GLOBALS['_MAX']['HTTP'] = 'http://';
}
}
}
// Maximum random number (use default if doesn't exist - eg the case when application is upgraded)
$GLOBALS['_MAX']['MAX_RAND'] = isset($GLOBALS['_MAX']['CONF']['priority']['randmax']) ?
$GLOBALS['_MAX']['CONF']['priority']['randmax'] : 2147483647;
// Always use UTC when outside the installer
if (substr($_SERVER['SCRIPT_NAME'], -11) != 'install.php') {
OA_setTimeZoneUTC();
}
}
function setupServerVariables()
{
// PHP-CGI/IIS combination does not set REQUEST_URI
if (empty($_SERVER['REQUEST_URI'])) {
$_SERVER['REQUEST_URI'] = $_SERVER['SCRIPT_NAME'];
if (!empty($_SERVER['QUERY_STRING'])) {
$_SERVER['REQUEST_URI'] .= '?' . $_SERVER['QUERY_STRING'];
}
}
}
function setupDeliveryConfigVariables()
{
if (!defined('MAX_PATH')) {
define('MAX_PATH', dirname(__FILE__).'/../..');
}
if (!defined('OX_PATH')) {
define('OX_PATH', dirname(__FILE__).'/../..');
}
if (!defined('LIB_PATH')) {
define('LIB_PATH', MAX_PATH. DIRECTORY_SEPARATOR. 'lib'. DIRECTORY_SEPARATOR. 'OX');
}
// Ensure that the initialisation has not been run before
if ( !(isset($GLOBALS['_MAX']['CONF']))) {
// Parse the Max configuration file
$GLOBALS['_MAX']['CONF'] = parseDeliveryIniFile();
}
// Set up the common configuration variables
setupConfigVariables();
}
function OA_setTimeZone($timezone)
{
// Set the new time zone
date_default_timezone_set($timezone);
// Set PEAR::Date_TimeZone default as well
//
// Ideally this should be a Date_TimeZone::setDefault() call, but for optimization
// purposes, we just override the global variable
$GLOBALS['_DATE_TIMEZONE_DEFAULT'] = $timezone;
}
function OA_setTimeZoneUTC()
{
OA_setTimeZone('UTC');
}
function OA_setTimeZoneLocal()
{
$tz = !empty($GLOBALS['_MAX']['PREF']['timezone']) ? $GLOBALS['_MAX']['PREF']['timezone'] : 'GMT';
OA_setTimeZone($tz);
}
function getHostName()
{
if (!empty($_SERVER['HTTP_HOST'])) {
$host = explode(':', $_SERVER['HTTP_HOST']);
$host = $host[0];
} else if (!empty($_SERVER['SERVER_NAME'])) {
$host = explode(':', $_SERVER['SERVER_NAME']);
$host = $host[0];
}
return $host;
}
function getHostNameWithPort()
{
if (!empty($_SERVER['HTTP_HOST'])) {
$host = $_SERVER['HTTP_HOST'];
} else if (!empty($_SERVER['SERVER_NAME'])) {
$host = $_SERVER['SERVER_NAME'];
}
return $host;
}
function setupIncludePath()
{
static $checkIfAlreadySet;
if (isset($checkIfAlreadySet)) {
return;
}
$checkIfAlreadySet = true;
$oxPearPath = MAX_PATH . DIRECTORY_SEPARATOR . 'lib' . DIRECTORY_SEPARATOR . 'pear';
$oxZendPath = MAX_PATH . DIRECTORY_SEPARATOR . 'lib';
set_include_path($oxPearPath . PATH_SEPARATOR . $oxZendPath . PATH_SEPARATOR . get_include_path());
}
function getMinimumRequiredMemory()
{
return $GLOBALS['_MAX']['REQUIRED_MEMORY']['PHP5'];
}
function increaseMemoryLimit($setMemory) {
$memory = getMemorySizeInBytes();
if ($memory == -1) {
// unlimited
return true;
}
if ($setMemory > $memory) {
if (@ini_set('memory_limit', $setMemory) === false) {
return false;
}
}
return true;
}
function getMemorySizeInBytes() {
$phpMemory = ini_get('memory_limit');
if (empty($phpMemory) || $phpMemory == -1) {
// unlimited
return -1;
}
$aSize = array(
'G' => 1073741824,
'M' => 1048576,
'K' => 1024
);
$size = $phpMemory;
foreach($aSize as $type => $multiplier) {
$pos = strpos($phpMemory, $type);
if (!$pos) {
$pos = strpos($phpMemory, strtolower($type));
}
if ($pos) {
$size = substr($phpMemory, 0, $pos) * $multiplier;
}
}
return $size;
}
setupServerVariables();
setupDeliveryConfigVariables();
$conf = $GLOBALS['_MAX']['CONF'];
$GLOBALS['_OA']['invocationType'] = array_search(basename($_SERVER['SCRIPT_FILENAME']), $conf['file']);
// Set the log file
if (!empty($conf['debug']['logfile'])) {
@ini_set('error_log', MAX_PATH . '/var/' . $conf['debug']['logfile']);
}
// Disable all notices and warnings, as some PAN code still
// generates PHP warnings in places
if (!empty($conf['debug']['production'])) {
error_reporting(E_ALL ^ E_NOTICE ^ E_WARNING);
} else {
// show all errors when developing
error_reporting(E_ALL);
}
$file = '/lib/max/Delivery/common.php';
$GLOBALS['_MAX']['FILES'][$file] = true;
$file = '/lib/max/Delivery/cookie.php';
$GLOBALS['_MAX']['FILES'][$file] = true;
$GLOBALS['_MAX']['COOKIE']['LIMITATIONS']['arrCappingCookieNames'] = array();
// Include the cookie storage library
if (!is_callable('MAX_cookieSet')) {
if (!empty($conf['cookie']['plugin']) && is_readable(MAX_PATH . "/plugins/cookieStorage/{$conf['cookie']['plugin']}.delivery.php")) {
include MAX_PATH . "/plugins/cookieStorage/{$conf['cookie']['plugin']}.delivery.php";
} else {
function MAX_cookieSet($name, $value, $expire, $path = '/', $domain = null) { return MAX_cookieClientCookieSet($name, $value, $expire, $path, $domain); }
function MAX_cookieUnset($name) { return MAX_cookieClientCookieUnset($name); }
function MAX_cookieFlush() { return MAX_cookieClientCookieFlush(); }
function MAX_cookieLoad() { return true; }
}
}
function MAX_cookieAdd($name, $value, $expire = 0)
{
if (!isset($GLOBALS['_MAX']['COOKIE']['CACHE'])) {
$GLOBALS['_MAX']['COOKIE']['CACHE'] = array();
}
$GLOBALS['_MAX']['COOKIE']['CACHE'][$name] = array($value, $expire);
}
function MAX_cookieSetViewerIdAndRedirect($viewerId) {
$aConf = $GLOBALS['_MAX']['CONF'];
MAX_cookieAdd($aConf['var']['viewerId'], $viewerId, _getTimeYearFromNow());
MAX_cookieFlush();
// Determine if the access to OpenX was made using HTTPS
if ($_SERVER['SERVER_PORT'] == $aConf['openads']['sslPort']) {
$url = MAX_commonConstructSecureDeliveryUrl(basename($_SERVER['PHP_SELF']));
} else {
$url = MAX_commonConstructDeliveryUrl(basename($_SERVER['PHP_SELF']));
}
$url .= "?{$aConf['var']['cookieTest']}=1&" . $_SERVER['QUERY_STRING'];
MAX_header("Location: {$url}");
exit;
}
function _getTimeThirtyDaysFromNow()
{
return MAX_commonGetTimeNow() + 2592000; // 30*24*60*60;
}
function _getTimeYearFromNow()
{
return MAX_commonGetTimeNow() + 31536000; // 365*24*60*60;
}
function _getTimeYearAgo()
{
return MAX_commonGetTimeNow() - 31536000; // 365*24*60*60;
}
function MAX_cookieUnpackCapping()
{
$conf = $GLOBALS['_MAX']['CONF'];
$cookieNames = $GLOBALS['_MAX']['COOKIE']['LIMITATIONS']['arrCappingCookieNames'];
if (!is_array($cookieNames))
return;
// For each type of cookie, unpack and add any newly set cookies to this array
foreach ($cookieNames as $cookieName) {
if (!empty($_COOKIE[$cookieName])) {
if (!is_array($_COOKIE[$cookieName])) {
$output = array();
$data = explode('_', $_COOKIE[$cookieName]);
foreach ($data as $pair) {
list($name, $value) = explode('.', $pair);
$output[$name] = $value;
}
$_COOKIE[$cookieName] = $output;
}
}
if (!empty($_COOKIE['_' . $cookieName]) && is_array($_COOKIE['_' . $cookieName])) {
foreach ($_COOKIE['_' . $cookieName] as $adId => $cookie) {
if (_isBlockCookie($cookieName)) {
$_COOKIE[$cookieName][$adId] = $cookie;
} else {
if (isset($_COOKIE[$cookieName][$adId])) {
$_COOKIE[$cookieName][$adId] += $cookie;
} else {
$_COOKIE[$cookieName][$adId] = $cookie;
}
}
// Delete the temporary capping cookie
MAX_cookieUnset("_{$cookieName}[{$adId}]");
}
}
}
}
function _isBlockCookie($cookieName)
{
return in_array($cookieName, array(
$GLOBALS['_MAX']['CONF']['var']['blockAd'],
$GLOBALS['_MAX']['CONF']['var']['blockCampaign'],
$GLOBALS['_MAX']['CONF']['var']['blockZone'],
$GLOBALS['_MAX']['CONF']['var']['lastView'],
$GLOBALS['_MAX']['CONF']['var']['lastClick'],
$GLOBALS['_MAX']['CONF']['var']['blockLoggingClick'],
));
}
function MAX_cookieGetUniqueViewerId($create = true)
{
$conf = $GLOBALS['_MAX']['CONF'];
if (isset($_COOKIE[$conf['var']['viewerId']])) {
$viewerId = $_COOKIE[$conf['var']['viewerId']];
} elseif ($create) {
$viewerId = md5(uniqid('', true));  // Need to find a way to generate this...
$GLOBALS['_MAX']['COOKIE']['newViewerId'] = true;
} else {
$viewerId = null;
}
return $viewerId;
}
function MAX_cookieGetCookielessViewerID()
{
if (empty($_SERVER['REMOTE_ADDR']) || empty($_SERVER['HTTP_USER_AGENT'])) {
return '';
}
$cookiePrefix = $GLOBALS['_MAX']['MAX_COOKIELESS_PREFIX'];
return $cookiePrefix . substr(md5($_SERVER['REMOTE_ADDR'].$_SERVER['HTTP_USER_AGENT']), 0, 32-(strlen($cookiePrefix)));
}
function MAX_Delivery_cookie_cappingOnRequest()
{
// view and xmlrpc invocation types must set capping-on-request for technical reasons
if (isset($GLOBALS['_OA']['invocationType']) &&
($GLOBALS['_OA']['invocationType'] == 'xmlrpc' || $GLOBALS['_OA']['invocationType'] == 'view')
) {
return true;
}
return !$GLOBALS['_MAX']['CONF']['logging']['adImpressions'];
}
function MAX_Delivery_cookie_setCapping($type, $id, $block = 0, $cap = 0, $sessionCap = 0)
{
$conf = $GLOBALS['_MAX']['CONF'];
$setBlock = false;
if ($cap > 0) {
// This capping cookie requires a "permanent" expiration time
$expire = MAX_commonGetTimeNow() + $conf['cookie']['permCookieSeconds'];
// The unpack capping cookies function adds this value to the counter, so to reset it we add a negative number
if (!isset($_COOKIE[$conf['var']['cap' . $type]][$id])) {
$value = 1;
$setBlock = true;
} else if ($_COOKIE[$conf['var']['cap' . $type]][$id] >= $cap) {
$value = -$_COOKIE[$conf['var']['cap' . $type]][$id]+1;
// Also reset the last-seen when resetting the frequency counter
$setBlock = true;
} else {
$value = 1;
}
MAX_cookieAdd("_{$conf['var']['cap' . $type]}[{$id}]", $value, $expire);
}
if ($sessionCap > 0) {
// The unpack capping cookies function deals with imcrementing the counter
// The expiry is set to 0 to make a session cookie
// The unpack capping cookies function adds this value to the counter, so to reset it we add a negative number
if (!isset($_COOKIE[$conf['var']['sessionCap' . $type]][$id])) {
$value = 1;
$setBlock = true;
} else if ($_COOKIE[$conf['var']['sessionCap' . $type]][$id] >= $sessionCap) {
$value = -$_COOKIE[$conf['var']['sessionCap' . $type]][$id]+1;
// Also reset the last-seen when resetting the frequency counter
$setBlock = true;
} else {
$value = 1;
}
MAX_cookieAdd("_{$conf['var']['sessionCap' . $type]}[{$id}]", $value, 0);
}
if ($block > 0 || $setBlock) {
// This blocking cookie is limited to 30 days
// Store a cookie using the current time so that the system knows when
// the last time this viewer saw this ad, an ad in this campaign or an
// ad in this zone
MAX_cookieAdd("_{$conf['var']['block' . $type]}[{$id}]", MAX_commonGetTimeNow(), _getTimeThirtyDaysFromNow());
}
}
function MAX_cookieClientCookieSet($name, $value, $expire, $path = '/', $domain = null)
{
if (isset($GLOBALS['_OA']['invocationType']) && $GLOBALS['_OA']['invocationType'] == 'xml-rpc') {
if (!isset($GLOBALS['_OA']['COOKIE']['XMLRPC_CACHE'])) {
$GLOBALS['_OA']['COOKIE']['XMLRPC_CACHE'] = array();
}
$GLOBALS['_OA']['COOKIE']['XMLRPC_CACHE'][$name] = array($value, $expire);
} else {
@setcookie($name, $value, $expire, $path, $domain);
}
}
function MAX_cookieClientCookieUnset($name)
{
MAX_cookieSet($name, false, _getTimeYearAgo());
// Work around a bug in IE where the cookie name is sometimes URL-encoded
MAX_cookieSet(str_replace('_', '%5F', urlencode($name)), false, _getTimeYearAgo());
}
function MAX_cookieClientCookieFlush()
{
$conf = $GLOBALS['_MAX']['CONF'];
MAX_cookieSendP3PHeaders();
if (!empty($GLOBALS['_MAX']['COOKIE']['CACHE'])) {
// Set cookies
reset($GLOBALS['_MAX']['COOKIE']['CACHE']);
while (list($name,$v) = each ($GLOBALS['_MAX']['COOKIE']['CACHE'])) {
list($value, $expire) = $v;
// Treat the viewerId cookie differently, (always set in client)
if ($name == $conf['var']['viewerId']) {
MAX_cookieClientCookieSet($name, $value, $expire, '/', (!empty($conf['cookie']['domain']) ? $conf['cookie']['domain'] : null));
} else {
MAX_cookieSet($name, $value, $expire, '/', (!empty($conf['cookie']['domain']) ? $conf['cookie']['domain'] : null));
}
}
// Clear cache
$GLOBALS['_MAX']['COOKIE']['CACHE'] = array();
}
// Compact all individual cookies into packed except for any cookies for the current bannerid
// We only need to set these packed cookies if new capping data has been merged
$cookieNames = $GLOBALS['_MAX']['COOKIE']['LIMITATIONS']['arrCappingCookieNames'];
if (!is_array($cookieNames))
return;
// For each type of cookie, repack if necessary
foreach ($cookieNames as $cookieName) {
// We only need to write out the compacted cookie if a new item is to be inserted (or updated)
if (empty($_COOKIE["_{$cookieName}"])) {
continue;
}
switch ($cookieName) {
case $conf['var']['blockAd']            :
case $conf['var']['blockCampaign']      :
case $conf['var']['blockZone']          : $expire = _getTimeThirtyDaysFromNow(); break;
case $conf['var']['capAd']              :
case $conf['var']['capCampaign']        :
case $conf['var']['capZone']            : $expire = _getTimeYearFromNow(); break;
case $conf['var']['sessionCapCampaign'] :
case $conf['var']['sessionCapAd']       :
case $conf['var']['sessionCapZone']     : $expire = 0; break;
}
if (!empty($_COOKIE[$cookieName]) && is_array($_COOKIE[$cookieName])) {
$data = array();
foreach ($_COOKIE[$cookieName] as $adId => $value) {
$data[] = "{$adId}.{$value}";
}
// RFC says that maximum cookie data length is 4096 bytes
// So we are assuming that 2048 will be valid in most browsers
// Discard oldest data until we are under the limit
while (strlen(implode('_', $data)) > 2048) {
$data = array_slice($data, 1);
}
MAX_cookieSet($cookieName, implode('_', $data), $expire, '/', (!empty($conf['cookie']['domain']) ? $conf['cookie']['domain'] : null));
}
}
}
function MAX_cookieSendP3PHeaders() {
// Send P3P headers
if ($GLOBALS['_MAX']['CONF']['p3p']['policies']) {
MAX_header("P3P: ". _generateP3PHeader());
}
}
function _generateP3PHeader()
{
$conf = $GLOBALS['_MAX']['CONF'];
$p3p_header = '';
if ($conf['p3p']['policies']) {
if ($conf['p3p']['policyLocation'] != '') {
$p3p_header .= " policyref=\"".$conf['p3p']['policyLocation']."\"";
}
if ($conf['p3p']['policyLocation'] != '' && $conf['p3p']['compactPolicy'] != '') {
$p3p_header .= ", ";
}
if ($conf['p3p']['compactPolicy'] != '') {
$p3p_header .= " CP=\"".$conf['p3p']['compactPolicy']."\"";
}
}
return $p3p_header;
}
$file = '/lib/max/Delivery/remotehost.php';
$GLOBALS['_MAX']['FILES'][$file] = true;
function MAX_remotehostSetInfo($run = false)
{
if (empty($GLOBALS['_OA']['invocationType']) || $run || ($GLOBALS['_OA']['invocationType'] != 'xml-rpc')) {
MAX_remotehostProxyLookup();
MAX_remotehostReverseLookup();
MAX_remotehostSetClientInfo();
MAX_remotehostSetGeoInfo();
}
}
function MAX_remotehostProxyLookup()
{
$conf = $GLOBALS['_MAX']['CONF'];
// Should proxy lookup conversion be performed?
if ($conf['logging']['proxyLookup']) {
// Determine if the viewer has come via an HTTP proxy
$proxy = false;
if (!empty($_SERVER['HTTP_VIA']) || !empty($_SERVER['HTTP_X_FORWARDED_FOR'])) {
$proxy = true;
} elseif (!empty($_SERVER['REMOTE_HOST'])) {
$aProxyHosts = array(
'proxy',
'cache',
'inktomi'
);
foreach ($aProxyHosts as $proxyName) {
if (strpos($_SERVER['REMOTE_HOST'], $proxyName) !== false) {
$proxy = true;
break;
}
}
}
// Has the viewer come via an HTTP proxy?
if ($proxy) {
// Try to find the "real" IP address the viewer has come from
$aHeaders = array(
'HTTP_FORWARDED',
'HTTP_FORWARDED_FOR',
'HTTP_X_FORWARDED',
'HTTP_X_FORWARDED_FOR',
'HTTP_CLIENT_IP'
);
foreach ($aHeaders as $header) {
if (!empty($_SERVER[$header])) {
$ip = $_SERVER[$header];
break;
}
}
if (!empty($ip)) {
// The "remote IP" may be a list, ensure that
// only the last item is used in that case
$ip = explode(',', $ip);
$ip = trim($ip[count($ip) - 1]);
// If the found address is not unknown or a private network address
if (($ip != 'unknown') && (!MAX_remotehostPrivateAddress($ip))) {
// Set the "real" remote IP address, and unset
// the remote host (as it will be wrong for the
// newly found IP address) and HTTP_VIA header
// (so that we don't accidently do this twice)
$_SERVER['REMOTE_ADDR'] = $ip;
$_SERVER['REMOTE_HOST'] = '';
$_SERVER['HTTP_VIA']    = '';
}
}
}
}
}
function MAX_remotehostReverseLookup()
{
// Is the remote host name already set?
if (empty($_SERVER['REMOTE_HOST'])) {
// Should reverse lookups be performed?
if ($GLOBALS['_MAX']['CONF']['logging']['reverseLookup']) {
$_SERVER['REMOTE_HOST'] = @gethostbyaddr($_SERVER['REMOTE_ADDR']);
} else {
$_SERVER['REMOTE_HOST'] = $_SERVER['REMOTE_ADDR'];
}
}
}
function MAX_remotehostSetClientInfo()
{
if ($GLOBALS['_MAX']['CONF']['logging']['sniff'] && isset($_SERVER['HTTP_USER_AGENT'])) {
if (!class_exists('phpSniff')) {
include MAX_PATH . '/lib/phpSniff/phpSniff.class.php';
}
$client = new phpSniff($_SERVER['HTTP_USER_AGENT']);
$GLOBALS['_MAX']['CLIENT'] = $client->_browser_info;
}
}
function MAX_remotehostSetGeoInfo()
{
if (!function_exists('parseDeliveryIniFile')) {
function parseDeliveryIniFile($configPath = null, $configFile = null, $sections = true)
{
// Set up the configuration .ini file path location
if (!$configPath) {
$configPath = MAX_PATH . '/var';
}
if ($configFile) {
$configFile = '.' . $configFile;
}
$host = getHostName();
$configFileName = $configPath . '/' . $host . $configFile . '.conf.php';
$conf = @parse_ini_file($configFileName, $sections);
if (isset($conf['realConfig'])) {
// added for backward compatibility - realConfig points to different config
$realconf = @parse_ini_file(MAX_PATH . '/var/' . $conf['realConfig'] . '.conf.php', $sections);
$conf = mergeConfigFiles($realconf, $conf);
}
if (!empty($conf)) {
return $conf;
} elseif ($configFile === '.plugin') {
// For plugins, if no configuration file is found, return the sane default values
$pluginType = basename($configPath);
$defaultConfig = MAX_PATH . '/plugins/' . $pluginType . '/default.plugin.conf.php';
$conf = @parse_ini_file($defaultConfig, $sections);
if ($conf !== false) {
// check for false here - it's possible file doesn't exist
return $conf;
}
echo "OpenX could not read the default configuration file for the {$pluginType} plugin";
exit(1);
}
// Check for a 'default.conf.php' file
$configFileName = $configPath . '/default' . $configFile . '.conf.php';
$conf = @parse_ini_file($configFileName, $sections);
if (isset($conf['realConfig'])) {
// added for backward compatibility - realConfig points to different config
$conf = @parse_ini_file(MAX_PATH . '/var/' . $conf['realConfig'] . '.conf.php', $sections);
}
if (!empty($conf)) {
return $conf;
}
// Check to ensure Max hasn't been installed
if (file_exists(MAX_PATH . '/var/INSTALLED')) {
echo "OpenX has been installed, but no configuration file was found.\n";
exit(1);
}
// Max hasn't been installed, so delivery engine can't run
echo "OpenX has not been installed yet -- please read the INSTALL.txt file.\n";
exit(1);
}
if (!function_exists('mergeConfigFiles'))
{
function mergeConfigFiles($realConfig, $fakeConfig)
{
//unset($fakeConfig['realConfig']);
foreach ($fakeConfig as $key => $value) {
if (is_array($value)) {
if (!isset($realConfig[$key])) {
$realConfig[$key] = array();
}
$realConfig[$key] = mergeConfigFiles($realConfig[$key], $value);
} else {
if (isset($realConfig[$key]) && is_array($realConfig[$key])) {
$realConfig[$key][0] = $value;
} else {
if (isset($realConfig) && !is_array($realConfig)) {
$temp = $realConfig;
$realConfig = array();
$realConfig[0] = $temp;
}
$realConfig[$key] = $value;
}
}
}
return $realConfig;
}
}
}
$aConf = $GLOBALS['_MAX']['CONF'];
$type = (!empty($aConf['geotargeting']['type'])) ? $aConf['geotargeting']['type'] : null;
if (!is_null($type) && $type != 'none') {
$aComponent = explode(':', $aConf['geotargeting']['type']);
if (!empty($aComponent[1]) && (!empty($aConf['pluginGroupComponents'][$aComponent[1]]))) {
$GLOBALS['_MAX']['CLIENT_GEO'] = OX_Delivery_Common_hook('getGeoInfo', array(), $type);
}
}
}
function MAX_remotehostPrivateAddress($ip)
{
setupIncludePath();
require_once 'Net/IPv4.php';
// Define the private address networks, see
// http://rfc.net/rfc1918.html
$aPrivateNetworks = array(
'10.0.0.0/8',
'172.16.0.0/12',
'192.168.0.0/16',
'127.0.0.0/24'
);
foreach ($aPrivateNetworks as $privateNetwork) {
if (Net_IPv4::ipInNetwork($ip, $privateNetwork)) {
return true;
}
}
return false;
}
$file = '/lib/max/Delivery/log.php';
$GLOBALS['_MAX']['FILES'][$file] = true;
$file = '/lib/max/Dal/Delivery.php';
$GLOBALS['_MAX']['FILES'][$file] = true;
function MAX_Dal_Delivery_Include()
{
static $included;
if (isset($included)) {
return;
}
$included = true;
$conf = $GLOBALS['_MAX']['CONF'];
if (isset($conf['origin']['type']) && is_readable(MAX_PATH . '/lib/OA/Dal/Delivery/' . strtolower($conf['origin']['type']) . '.php')) {
require(MAX_PATH . '/lib/OA/Dal/Delivery/' . strtolower($conf['origin']['type']) . '.php');
} else {
require(MAX_PATH . '/lib/OA/Dal/Delivery/' . strtolower($conf['database']['type']) . '.php');
}
}
function MAX_trackerbuildJSVariablesScript($trackerid, $conversionInfo, $trackerJsCode = null)
{
$conf = $GLOBALS['_MAX']['CONF'];
$buffer = '';
$url = MAX_commonGetDeliveryUrl($conf['file']['conversionvars']);
$tracker = MAX_cacheGetTracker($trackerid);
$variables = MAX_cacheGetTrackerVariables($trackerid);
$variableQuerystring = '';
if (empty($trackerJsCode)) {
$trackerJsCode = md5(uniqid('', true));
} else {
// Appended tracker - set method to default
$tracker['variablemethod'] = 'default';
}
if (!empty($variables)) {
if ($tracker['variablemethod'] == 'dom') {
$buffer .= "
function MAX_extractTextDom(o)
{
var txt = '';
if (o.nodeType == 3) {
txt = o.data;
} else {
for (var i = 0; i < o.childNodes.length; i++) {
txt += MAX_extractTextDom(o.childNodes[i]);
}
}
return txt;
}
function MAX_TrackVarDom(id, v)
{
if (max_trv[id][v]) { return; }
var o = document.getElementById(v);
if (o) {
max_trv[id][v] = escape(o.tagName == 'INPUT' ? o.value : MAX_extractTextDom(o));
}
}";
$funcName = 'MAX_TrackVarDom';
} elseif ($tracker['variablemethod'] == 'default') {
$buffer .= "
function MAX_TrackVarDefault(id, v)
{
if (max_trv[id][v]) { return; }
if (typeof(window[v]) == undefined) { return; }
max_trv[id][v] = window[v];
}";
$funcName = 'MAX_TrackVarDefault';
} else {
$buffer .= "
function MAX_TrackVarJs(id, v, c)
{
if (max_trv[id][v]) { return; }
if (typeof(window[v]) == undefined) { return; }
if (typeof(c) != 'undefined') {
eval(c);
}
max_trv[id][v] = window[v];
}";
$funcName = 'MAX_TrackVarJs';
}
$buffer .= "
if (!max_trv) { var max_trv = new Array(); }
if (!max_trv['{$trackerJsCode}']) { max_trv['{$trackerJsCode}'] = new Array(); }";
foreach($variables as $key => $variable) {
$variableQuerystring .= "&{$variable['name']}=\"+max_trv['{$trackerJsCode}']['{$variable['name']}']+\"";
if ($tracker['variablemethod'] == 'custom') {
$buffer .= "
{$funcName}('{$trackerJsCode}', '{$variable['name']}', '".addcslashes($variable['variablecode'], "'")."');";
} else {
$buffer .= "
{$funcName}('{$trackerJsCode}', '{$variable['name']}');";
}
}
if (!empty($variableQuerystring)) {
$buffer .= "
document.write (\"<\" + \"script language='JavaScript' type='text/javascript' src='\");
document.write (\"$url?trackerid=$trackerid&server_conv_id={$conversionInfo['server_conv_id']}&server_raw_ip={$conversionInfo['server_raw_ip']}{$variableQuerystring}'\");";
$buffer .= "\n\tdocument.write (\"><\\/scr\"+\"ipt>\");";
}
}
if(!empty($tracker['appendcode'])) {
// Add the correct "inherit" parameter if a OpenX trackercode was found
$tracker['appendcode'] = preg_replace('/("\?trackerid=\d+&amp;inherit)=1/', '$1='.$trackerJsCode, $tracker['appendcode']);
$jscode = MAX_javascriptToHTML($tracker['appendcode'], "MAX_{$trackerid}_appendcode");
// Replace template style variables
$jscode = preg_replace("/\{m3_trackervariable:(.+?)\}/", "\"+max_trv['{$trackerJsCode}']['$1']+\"", $jscode);
$buffer .= "\n".preg_replace('/^/m', "\t", $jscode)."\n";
}
if (empty($buffer)) {
$buffer = "document.write(\"\");";
}
return $buffer;
}
function MAX_trackerCheckForValidAction($trackerid)
{
// Get all creatives that are linked to this tracker
$aTrackerLinkedAds = MAX_cacheGetTrackerLinkedCreatives($trackerid);
// This tracker is not linked to any creatives
if (empty($aTrackerLinkedAds)) {
return false;
}
// Note: Constants are not included n the delivery engine, the values below map to the values defined in constants.php
$aPossibleActions = _getActionTypes();
$now = MAX_commonGetTimeNow();
$aConf = $GLOBALS['_MAX']['CONF'];
$aMatchingActions = array();
// Iterate over all creatives linked to this tracker...
foreach ($aTrackerLinkedAds as $creativeId => $aLinkedInfo) {
// Iterate over all possible actions (currently only "view" and "click")
foreach ($aPossibleActions as $actionId => $action) {
// If there is both a connection window set, and this creative has been actioned
if (!empty($aLinkedInfo[$action . '_window']) && !empty($_COOKIE[$aConf['var']['last' . ucfirst($action)]][$creativeId])) {
list($lastAction, $zoneId) = explode('-', $_COOKIE[$aConf['var']['last' . ucfirst($action)]][$creativeId]);
// Decode the base32 timestamp
$lastAction = MAX_commonUnCompressInt($lastAction);
// Calculate how long ago this action occured
$lastSeenSecondsAgo = $now - $lastAction;
// If the action occured within the window (and sanity check that it's > 0), record this as a matching action
if ($lastSeenSecondsAgo <= $aLinkedInfo[$action . '_window'] && $lastSeenSecondsAgo > 0) {
// Index the matching array against the # seconds ago that the action occured
$aMatchingActions[$lastSeenSecondsAgo] = array(
'action_type'   => $actionId,
'tracker_type'  => $aLinkedInfo['tracker_type'],
'status'        => $aLinkedInfo['status'],
'cid'           => $creativeId,
'zid'           => $zoneId,
'dt'            => $lastAction,
'window'        => $aLinkedInfo[$action . '_window'],
);
}
}
}
}
// If no actions matched, return false
if (empty($aMatchingActions)) {
return false;
}
// Sort by ascending #seconds since action
ksort($aMatchingActions);
// Return the first matching action
return array_shift($aMatchingActions);
}
function MAX_trackerDeleteActionFromCookie($aConnection)
{
$trackerTypes = _getTrackerTypes();
if ($trackerTypes[$aConnection['tracker_type']] != 'sale') {
// We only clear the cookie information for "sale" trackers
return;
}
// Haven't planned how this will be achieved yet...
// The cookie packing mechanism wasn't built to allow deleting items from the compacted array
// I'm guessing something like set _cookieName[adId] = "false", then unset from packed when recompacting
$actionTypes = _getActionTypes();
$aConf = $GLOBALS['_MAX']['CONF'];
$cookieName = '_' . $aConf['var']['last' . ucfirst($actionTypes[$aConnection['action_type']])] . "[{$aConnection['cid']}]";
MAX_cookieAdd($cookieName, 'false', _getTimeThirtyDaysFromNow());
}
function _getActionTypes()
{
return array(0 => 'view', 1 => 'click');
}
function _getTrackerTypes()
{
return array(1 => 'sale', 2 => 'lead', 3 => 'signup');
}
function MAX_Delivery_log_logAdRequest($adId, $zoneId)
{
if (_viewersHostOkayToLog()) {
// Call all registered plugins that use the "logRequest" hook
OX_Delivery_Common_hook('logRequest', array($adId, $zoneId));
}
}
function MAX_Delivery_log_logAdImpression($adId, $zoneId)
{
if (_viewersHostOkayToLog()) {
// Call all registered plugins that use the "logImpression" hook
OX_Delivery_Common_hook('logImpression', array($adId, $zoneId));
}
}
function MAX_Delivery_log_logAdClick($adId, $zoneId)
{
if (_viewersHostOkayToLog()) {
// Call all registered plugins that use the "logClick" hook
OX_Delivery_Common_hook('logClick', array($adId, $zoneId));
}
}
function MAX_Delivery_log_logConversion($trackerId, $aConversion)
{
if (_viewersHostOkayToLog()) {
// Prepare the raw database IP address, depending on if OpenX is running
// with multiple delivery servers, or just a single server
$aConf = $GLOBALS['_MAX']['CONF'];
if (empty($aConf['rawDatabase']['host'])) {
if (!empty($aConf['lb']['enabled'])) {
$aConf['rawDatabase']['host'] = $_SERVER['SERVER_ADDR'];
} else {
$aConf['rawDatabase']['host'] = 'singleDB';
}
}
if (isset($aConf['rawDatabase']['serverRawIp'])) {
$serverRawIp = $aConf['rawDatabase']['serverRawIp'];
} else {
$serverRawIp = $aConf['rawDatabase']['host'];
}
// Call all registered plugins that use the "logConversion" hook
$aConversionInfo = OX_Delivery_Common_hook('logConversion', array($trackerId, $serverRawIp, $aConversion));
// Check that the conversion was logged correctly
if (is_array($aConversionInfo)) {
// If this was a "sale" type conversion, then clear the cookie data
MAX_trackerDeleteActionFromCookie($aConnection);
// Return the result
return $aConversionInfo;
}
}
return false;
}
function MAX_Delivery_log_logVariableValues($aVariables, $trackerId, $serverConvId, $serverRawIp)
{
$aConf = $GLOBALS['_MAX']['CONF'];
// Get the variable information, including the Variable ID
foreach ($aVariables as $aVariable) {
if (isset($_GET[$aVariable['name']])) {
$value = $_GET[$aVariable['name']];
// Do not save variable if empty or if the JS engine set it to "undefined"
if (!strlen($value) || $value == 'undefined') {
unset($aVariables[$aVariable['variable_id']]);
continue;
}
// Sanitize by datatype
switch ($aVariable['type']) {
case 'int':
case 'numeric':
// Strip useless chars, such as currency
$value = preg_replace('/[^0-9.]/', '', $value);
$value = floatval($value);
break;
case 'date':
if (!empty($value)) {
$value = date('Y-m-d H:i:s', strtotime($value));
} else {
$value = '';
}
break;
}
} else {
// Do not save anything if the variable isn't set
unset($aVariables[$aVariable['variable_id']]);
continue;
}
$aVariables[$aVariable['variable_id']]['value'] = $value;
}
if (count($aVariables)) {
OX_Delivery_Common_hook('logConversionVariable', array($aVariables, $trackerId, $serverConvId, $serverRawIp));
}
}
function _viewersHostOkayToLog()
{
$aConf = $GLOBALS['_MAX']['CONF'];
$agent = strtolower($_SERVER['HTTP_USER_AGENT']);
// Check the user-agent against the list of known browsers (if set)
if (!empty($aConf['logging']['enforceUserAgents'])) {
$aKnownBrowsers = explode('|', strtolower($aConf['logging']['enforceUserAgents']));
$allowed = false;
foreach ($aKnownBrowsers as $browser) {
if (strpos($agent, $browser) !== false) {
$allowed = true;
break;
}
}
if (!$allowed) return false;
}
// Check the user-agent against the list of known bots (if set)
if (!empty($aConf['logging']['ignoreUserAgents'])) {
$aKnownBots = explode('|', strtolower($aConf['logging']['ignoreUserAgents']));
foreach ($aKnownBots as $bot) {
if (strpos($agent, $bot) !== false) {
return false;
}
}
}
// Check if this IP address has been blocked
if (!empty($aConf['logging']['ignoreHosts'])) {
$hosts = str_replace(',', '|', $aConf['logging']['ignoreHosts']);
$hosts = '#('.$hosts.')$#i';
// Format the hosts to ignore in a PCRE format
$hosts = str_replace('.', '\.', $hosts);
$hosts = str_replace('*', '[^.]+', $hosts);
// Check if the viewer's IP address is in the ignore list
if (preg_match($hosts, $_SERVER['REMOTE_ADDR'])) {
return false;
}
// Check if the viewer's hostname is in the ignore list
if (preg_match($hosts, $_SERVER['REMOTE_HOST'])) {
return false;
}
}
return true;
}
function MAX_Delivery_log_getArrGetVariable($name)
{
$varName = $GLOBALS['_MAX']['CONF']['var'][$name];
return isset($_GET[$varName]) ? explode($GLOBALS['_MAX']['MAX_DELIVERY_MULTIPLE_DELIMITER'], $_GET[$varName]) : array();
}
function MAX_Delivery_log_ensureIntegerSet(&$aArray, $index)
{
if (!is_array($aArray)) {
$aArray = array();
}
if (empty($aArray[$index])) {
$aArray[$index] = 0;
} else {
if (!is_integer($aArray[$index])) {
$aArray[$index] = intval($aArray[$index]);
}
}
}
function MAX_Delivery_log_setAdLimitations($index, $aAds, $aCaps)
{
_setLimitations('Ad', $index, $aAds, $aCaps);
}
function MAX_Delivery_log_setCampaignLimitations($index, $aCampaigns, $aCaps)
{
_setLimitations('Campaign', $index, $aCampaigns, $aCaps);
}
function MAX_Delivery_log_setZoneLimitations($index, $aZones, $aCaps)
{
_setLimitations('Zone', $index, $aZones, $aCaps);
}
function MAX_Delivery_log_setLastAction($index, $aAdIds, $aZoneIds, $aSetLastSeen, $action = 'view')
{
$aConf = $GLOBALS['_MAX']['CONF'];
if (!empty($aSetLastSeen[$index])) {
MAX_cookieAdd("_{$aConf['var']['last' . ucfirst($action)]}[{$aAdIds[$index]}]", MAX_commonCompressInt(MAX_commonGetTimeNow()) . "-" . $aZoneIds[$index], _getTimeThirtyDaysFromNow());
}
}
function MAX_Delivery_log_setClickBlocked($index, $aAdIds)
{
$aConf = $GLOBALS['_MAX']['CONF'];
MAX_cookieAdd("_{$aConf['var']['blockLoggingClick']}[{$aAdIds[$index]}]", MAX_commonCompressInt(MAX_commonGetTimeNow()), _getTimeThirtyDaysFromNow());
}
function MAX_Delivery_log_isClickBlocked($adId, $aBlockLoggingClick)
{
if (isset($GLOBALS['conf']['logging']['blockAdClicksWindow']) && $GLOBALS['conf']['logging']['blockAdClicksWindow'] != 0) {
if (isset($aBlockLoggingClick[$adId])) {
$endBlock = MAX_commonUnCompressInt($aBlockLoggingClick[$adId]) + $GLOBALS['conf']['logging']['blockAdClicksWindow'];
if ($endBlock >= MAX_commonGetTimeNow()) {
return true;
}
}
}
return false;
}
function _setLimitations($type, $index, $aItems, $aCaps)
{
// Ensure that the capping values for this item are set
MAX_Delivery_log_ensureIntegerSet($aCaps['block'], $index);
MAX_Delivery_log_ensureIntegerSet($aCaps['capping'], $index);
MAX_Delivery_log_ensureIntegerSet($aCaps['session_capping'], $index);
// Set the capping cookies
MAX_Delivery_cookie_setCapping(
$type,
$aItems[$index],
$aCaps['block'][$index],
$aCaps['capping'][$index],
$aCaps['session_capping'][$index]
);
}
function MAX_commonGetDeliveryUrl($file = null)
{
$conf = $GLOBALS['_MAX']['CONF'];
if (!empty($_SERVER['SERVER_PORT']) && $_SERVER['SERVER_PORT'] == $conf['openads']['sslPort']) {
$url = MAX_commonConstructSecureDeliveryUrl($file);
} else {
$url = MAX_commonConstructDeliveryUrl($file);
}
return $url;
}
function MAX_commonConstructDeliveryUrl($file)
{
$conf = $GLOBALS['_MAX']['CONF'];
return 'http://' . $conf['webpath']['delivery'] . '/' . $file;
}
function MAX_commonConstructSecureDeliveryUrl($file)
{
$conf = $GLOBALS['_MAX']['CONF'];
if ($conf['openads']['sslPort'] != 443) {
// Fix the delivery host
$path = preg_replace('#/#', ':' . $conf['openads']['sslPort'] . '/', $conf['webpath']['deliverySSL']);
} else {
$path = $conf['webpath']['deliverySSL'];
}
return 'https://' . $path . '/' . $file;
}
function MAX_commonConstructPartialDeliveryUrl($file, $ssl = false)
{
$conf = $GLOBALS['_MAX']['CONF'];
if ($ssl) {
return '//' . $conf['webpath']['deliverySSL'] . '/' . $file;
} else {
return '//' . $conf['webpath']['delivery'] . '/' . $file;
}
}
function MAX_commonRemoveSpecialChars(&$var)
{
static $magicQuotes;
if (!isset($magicQuotes)) {
$magicQuotes = get_magic_quotes_gpc();
}
if (isset($var)) {
if (!is_array($var)) {
if ($magicQuotes) {
$var = stripslashes($var);
}
$var = strip_tags($var);
$var = str_replace(array("\n", "\r"), array('', ''), $var);
$var = trim($var);
} else {
array_walk($var, 'MAX_commonRemoveSpecialChars');
}
}
}
function MAX_commonConvertEncoding($content, $toEncoding, $fromEncoding = 'UTF-8', $aExtensions = null) {
// Sanity check :)
if (($toEncoding == $fromEncoding) || empty($toEncoding)) {
return $content;
}
// Default extensions
if (!isset($aExtensions) || !is_array($aExtensions)) {
$aExtensions = array('iconv', 'mbstring', 'xml');
}
// Walk arrays
if (is_array($content)) {
foreach ($content as $key => $value) {
$content[$key] = MAX_commonConvertEncoding($value, $toEncoding, $fromEncoding, $aExtensions);
}
return $content;
} else {
// Uppercase charsets
$toEncoding   = strtoupper($toEncoding);
$fromEncoding = strtoupper($fromEncoding);
// Charset mapping
$aMap = array();
$aMap['mbstring']['WINDOWS-1255'] = 'ISO-8859-8'; // Best match to convert hebrew w/ mbstring
$aMap['xml']['ISO-8859-15'] = 'ISO-8859-1'; // Best match
// Start conversion
$converted = false;
foreach ($aExtensions as $extension) {
$mappedFromEncoding = isset($aMap[$extension][$fromEncoding]) ? $aMap[$extension][$fromEncoding] : $fromEncoding;
$mappedToEncoding   = isset($aMap[$extension][$toEncoding])   ? $aMap[$extension][$toEncoding]   : $toEncoding;
switch ($extension) {
case 'iconv':
if (function_exists('iconv')) {
$converted = @iconv($mappedFromEncoding, $mappedToEncoding, $content);
}
break;
case 'mbstring':
if (function_exists('mb_convert_encoding')) {
$converted = @mb_convert_encoding($content, $mappedToEncoding, $mappedFromEncoding);
}
break;
case 'xml':
if (function_exists('utf8_encode')) {
// Does this actually help us at all? it can only convert between UTF8 and ISO-8859-1
if ($mappedToEncoding == 'UTF-8' && $mappedFromEncoding == 'ISO-8859-1') {
$converted = utf8_encode($content);
} elseif ($mappedToEncoding == 'ISO-8859-1' && $mappedFromEncoding == 'UTF-8') {
$converted = utf8_decode($content);
}
}
break;
}
}
return $converted ? $converted : $content;
}
}
function MAX_commonSendContentTypeHeader($type = 'text/html', $charset = null)
{
$header = 'Content-type: ' . $type;
if (!empty($charset)) { $header .= '; charset=' . $charset; }
MAX_header($header);
}
function MAX_commonSetNoCacheHeaders()
{
MAX_header('Pragma: no-cache');
MAX_header('Cache-Control: private, max-age=0, no-cache');
MAX_header('Expires: Mon, 26 Jul 1997 05:00:00 GMT');
}
function MAX_commonAddslashesRecursive($a)
{
if (is_array($a)) {
reset($a);
while (list($k,$v) = each($a)) {
$a[$k] = MAX_commonAddslashesRecursive($v);
}
reset ($a);
return ($a);
} else {
return is_null($a) ? null : addslashes($a);
}
}
function MAX_commonRegisterGlobalsArray($args = array())
{
static $magic_quotes_gpc;
if (!isset($magic_quotes_gpc)) {
$magic_quotes_gpc = ini_get('magic_quotes_gpc');
}
$found = false;
foreach($args as $key) {
if (isset($_GET[$key])) {
$value = $_GET[$key];
$found = true;
}
if (isset($_POST[$key])) {
$value = $_POST[$key];
$found = true;
}
if ($found) {
if (!$magic_quotes_gpc) {
if (!is_array($value)) {
$value = addslashes($value);
} else {
$value = MAX_commonAddslashesRecursive($value);
}
}
$GLOBALS[$key] = $value;
$found = false;
}
}
}
function MAX_commonDeriveSource($source)
{
return MAX_commonEncrypt(trim(urldecode($source)));
}
function MAX_commonEncrypt($string)
{
$convert = '';
if (isset($string) && substr($string,1,4) != 'obfs' && $GLOBALS['_MAX']['CONF']['delivery']['obfuscate']) {
$strLen = strlen($string);
for ($i=0; $i < $strLen; $i++) {
$dec = ord(substr($string,$i,1));
if (strlen($dec) == 2) {
$dec = 0 . $dec;
}
$dec = 324 - $dec;
$convert .= $dec;
}
$convert = '{obfs:' . $convert . '}';
return ($convert);
} else {
return $string;
}
}
function MAX_commonDecrypt($string)
{
$conf = $GLOBALS['_MAX']['CONF'];
$convert = '';
if (isset($string) && substr($string,1,4) == 'obfs' && $conf['delivery']['obfuscate']) {
$strLen = strlen($string);
for ($i=6; $i < $strLen-1; $i = $i+3) {
$dec = substr($string,$i,3);
$dec = 324 - $dec;
$dec = chr($dec);
$convert .= $dec;
}
return ($convert);
} else {
return($string);
}
}
function MAX_commonInitVariables()
{
MAX_commonRegisterGlobalsArray(array('context', 'source', 'target', 'withText', 'withtext', 'ct0', 'what', 'loc', 'referer', 'zoneid', 'campaignid', 'bannerid', 'clientid', 'charset'));
global $context, $source, $target, $withText, $withtext, $ct0, $what, $loc, $referer, $zoneid, $campaignid, $bannerid, $clientid, $charset;
if (isset($withText) && !isset($withtext))  $withtext = $withText;
$withtext   = (isset($withtext) && is_numeric($withtext) ? $withtext : 0  );
$ct0        = (isset($ct0)          ? $ct0          : ''        );
$context    = (isset($context)      ? $context      : array()   );
$target     = (isset($target)  && (!empty($target))  && (!strpos($target , chr(32))) ? $target       : '_blank'  );
$charset    = (isset($charset) && (!empty($charset)) && (!strpos($charset, chr(32))) ? $charset      : 'UTF-8'  );
$bannerid   = (isset($bannerid)     && is_numeric($bannerid)    ? $bannerid     : ''        );
$campaignid = (isset($campaignid)   && is_numeric($campaignid)  ? $campaignid   : ''        );
$clientid   = (isset($clientid)     && is_numeric($clientid)    ? $clientid     : ''        );
$zoneid     = (isset($zoneid)       && is_numeric($zoneid)      ? $zoneid       : ''        );
if (!isset($what))
{
if (!empty($bannerid)) {
$what = 'bannerid:'.$bannerid;
} elseif (!empty($campaignid)) {
$what = 'campaignid:'.$campaignid;
} elseif (!empty($zoneid)) {
$what = 'zone:'.$zoneid;
} else {
$what = '';
}
}
elseif (preg_match('/^([a-z]+):(\d+)$/', $what, $matches))
{
switch ($matches[1])
{
case 'zoneid':
case 'zone':
$zoneid     = $matches[2];
break;
case 'bannerid':
$bannerid   = $matches[2];
break;
case 'campaignid':
$campaignid = $matches[2];
break;
case 'clientid':
$clientid   = $matches[2];
break;
}
}
// 2.0 backwards compatibility - clientid parameter was used to fetch a campaign
if (!isset($clientid)) $clientid = '';
if (!isset($campaignid))  $campaignid = $clientid;
$source = MAX_commonDeriveSource($source);
if (!empty($loc)) {
$loc = stripslashes($loc);
} elseif (!empty($_SERVER['HTTP_REFERER'])) {
$loc = $_SERVER['HTTP_REFERER'];
} else {
$loc = '';
}
// Set real referer - Only valid if passed in
if (!empty($referer)) {
$_SERVER['HTTP_REFERER'] = stripslashes($referer);
} else {
if (isset($_SERVER['HTTP_REFERER'])) unset($_SERVER['HTTP_REFERER']);
}
$GLOBALS['_MAX']['COOKIE']['LIMITATIONS']['arrCappingCookieNames'] = array(
$GLOBALS['_MAX']['CONF']['var']['blockAd'],
$GLOBALS['_MAX']['CONF']['var']['capAd'],
$GLOBALS['_MAX']['CONF']['var']['sessionCapAd'],
$GLOBALS['_MAX']['CONF']['var']['blockCampaign'],
$GLOBALS['_MAX']['CONF']['var']['capCampaign'],
$GLOBALS['_MAX']['CONF']['var']['sessionCapCampaign'],
$GLOBALS['_MAX']['CONF']['var']['blockZone'],
$GLOBALS['_MAX']['CONF']['var']['capZone'],
$GLOBALS['_MAX']['CONF']['var']['sessionCapZone'],
$GLOBALS['_MAX']['CONF']['var']['lastClick'],
$GLOBALS['_MAX']['CONF']['var']['lastView'],
$GLOBALS['_MAX']['CONF']['var']['blockLoggingClick'],
);
}
function MAX_commonDisplay1x1()
{
MAX_header('Content-Type: image/gif');
MAX_header('Content-Length: 43');
// 1 x 1 gif
echo base64_decode('R0lGODlhAQABAIAAAP///wAAACH5BAAAAAAALAAAAAABAAEAAAICRAEAOw==');
}
function MAX_commonGetTimeNow()
{
static $now;
if (!isset($now)) {
$now = $GLOBALS['_MAX']['NOW'] = time();
}
return $now;
}
function MAX_header($value)
{
header($value);
}
function MAX_redirect($url)
{
header('Location: '.$url);
MAX_sendStatusCode(302);
}
function MAX_sendStatusCode($iStatusCode) {
$aConf = $GLOBALS['_MAX']['CONF'];
$arr = array(
100 => 'Continue',
101 => 'Switching Protocols',
200 => 'OK',
201 => 'Created',
202 => 'Accepted',
203 => 'Non-Authoritative Information',
204 => 'No Content',
205 => 'Reset Content',
206 => 'Partial Content',
300 => 'Multiple Choices',
301 => 'Moved Permanently',
302 => 'Found',
303 => 'See Other',
304 => 'Not Modified',
305 => 'Use Proxy',
306 => '[Unused]',
307 => 'Temporary Redirect',
400 => 'Bad Request',
401 => 'Unauthorized',
402 => 'Payment Required',
403 => 'Forbidden',
404 => 'Not Found',
405 => 'Method Not Allowed',
406 => 'Not Acceptable',
407 => 'Proxy Authentication Required',
408 => 'Request Timeout',
409 => 'Conflict',
410 => 'Gone',
411 => 'Length Required',
412 => 'Precondition Failed',
413 => 'Request Entity Too Large',
414 => 'Request-URI Too Long',
415 => 'Unsupported Media Type',
416 => 'Requested Range Not Satisfiable',
417 => 'Expectation Failed',
500 => 'Internal Server Error',
501 => 'Not Implemented',
502 => 'Bad Gateway',
503 => 'Service Unavailable',
504 => 'Gateway Timeout',
505 => 'HTTP Version Not Supported'
);
if (isset($arr[$iStatusCode])) {
$text = $iStatusCode . ' ' . $arr[$iStatusCode];
// Using header('Status: foo') with CGI sapis appears to be deprecated but PHP-CGI seems to discard
// the Reason-Phrase and some webservers do not add a default one. Some bad spiders do not cope
// with that, that's why we added the cgiForceStatusHeader confgiuration directive. If enabled
// with CGI sapis, OpenX will use a "Status: NNN Reason" header, which seems to fix the behaviour
// on the tested webserver (Apache 1.3, running php-cgi)
if (!empty($aConf['delivery']['cgiForceStatusHeader']) && strpos(php_sapi_name(), 'cgi') !== 0) {
MAX_header('Status: ' . $text);
} else {
MAX_header($_SERVER["SERVER_PROTOCOL"] .' ' . $text);
}
}
}
function MAX_commonPackContext($context = array())
{
//return base64_encode(serialize($context));
$include = array();
$exclude = array();
foreach ($context as $idx => $value) {
reset($value);
list($key, $value) = each($value);
list($item,$id) = explode(':', $value);
switch ($item) {
case 'campaignid':  $value = 'c:' . $id; break;
case 'clientid':    $value = 'a:' . $id; break;
case 'bannerid':    $value = 'b:' . $id; break;
case 'companionid': $value = 'p:' . $id; break;
}
switch ($key) {
case '!=': $exclude[] = $value; break;
case '==': $include[] = $value; break;
}
}
return base64_encode(implode('#', $exclude) . '|' . implode('#', $include));
}
function MAX_commonUnpackContext($context = '')
{
//return unserialize(base64_decode($context));
list($exclude,$include) = explode('|', base64_decode($context));
return array_merge(_convertContextArray('!=', explode('#', $exclude)), _convertContextArray('==', explode('#', $include)));
}
function MAX_commonCompressInt($int)
{
return base_convert($int, 10, 36);
}
function MAX_commonUnCompressInt($string)
{
return base_convert($string, 36, 10);
}
function _convertContextArray($key, $array)
{
$unpacked = array();
foreach ($array as $value) {
if (empty($value)) { continue; }
list($item, $id) = explode(':', $value);
switch ($item) {
case 'c': $unpacked[] = array($key => 'campaignid:' . $id); break;
case 'a': $unpacked[] = array($key => 'clientid:'   . $id); break;
case 'b': $unpacked[] = array($key => 'bannerid:'   . $id); break;
case 'p': $unpacked[] = array($key => 'companionid:'.$id); break;
}
}
return $unpacked;
}
function OX_Delivery_Common_hook($hookName, $aParams = array(), $functionName = '')
{
$return = null;
// When a $functionname is passed in we use that function/component-identifier and execute the hook
if (!empty($functionName)) {
// Right now, we're allowing either a plain function to be executed, or a component-identifier
// we may remove the ability to pass a plain function in the future
$aParts = explode(':', $functionName);
if (count($aParts) === 3) {
$functionName = OX_Delivery_Common_getFunctionFromComponentIdentifier($functionName, $hookName);
}
if (function_exists($functionName)) {
$return = call_user_func_array($functionName, $aParams);
}
} else {
// When no $functionName is passed in, we execute all components which are registered for this hook
if (!empty($GLOBALS['_MAX']['CONF']['deliveryHooks'][$hookName])) {
$return = array();
$hooks = explode('|', $GLOBALS['_MAX']['CONF']['deliveryHooks'][$hookName]);
foreach ($hooks as $identifier) {
$functionName = OX_Delivery_Common_getFunctionFromComponentIdentifier($identifier, $hookName);
if (function_exists($functionName)) {
$return[$identifier] = call_user_func_array($functionName, $aParams);
}
}
}
}
return $return;
}
function OX_Delivery_Common_getFunctionFromComponentIdentifier($identifier, $hook = null)
{
$aInfo = explode(':', $identifier);
$functionName = 'Plugin_' . implode('_', $aInfo) . '_Delivery' . (!empty($hook) ? '_' . $hook : '');
if (!function_exists($functionName)) {
// Function doesn't exist, include the generic merged delivery file
_includeDeliveryPluginFile('/var/plugins/cache/mergedDeliveryFunctions.php');
if (!function_exists($functionName)) {
// Function doesn't exist, include the relevant plugin file
_includeDeliveryPluginFile($GLOBALS['_MAX']['CONF']['pluginPaths']['extensions'] . '/' . implode('/', $aInfo) . '.delivery.php');
if (!function_exists($functionName)) {
// Function or function file doesn't exist, use the "parent" function
_includeDeliveryPluginFile('/lib/OX/Extension/' . $aInfo[0] .  '/' . $aInfo[0] . 'Delivery.php');
$functionName = 'Plugin_' . $aInfo[0] . '_delivery';
if (!empty($hook) && function_exists($functionName . '_' . $hook)) {
$functionName .= '_' . $hook;
}
}
}
}
return $functionName;
}
function _includeDeliveryPluginFile($fileName)
{
if (!in_array($fileName, array_keys($GLOBALS['_MAX']['FILES']))) {
$GLOBALS['_MAX']['FILES'][$fileName] = true;
if (file_exists(MAX_PATH . $fileName)) {
include MAX_PATH . $fileName;
}
}
}
$file = '/lib/max/Delivery/cache.php';
$GLOBALS['_MAX']['FILES'][$file] = true;
define ('OA_DELIVERY_CACHE_FUNCTION_ERROR', 'Function call returned an error');
$GLOBALS['OA_Delivery_Cache'] = array(
'prefix' => 'deliverycache_',
'host'   => getHostName(),
'expiry' => $GLOBALS['_MAX']['CONF']['delivery']['cacheExpire']
);
function OA_Delivery_Cache_fetch($name, $isHash = false, $expiryTime = null)
{
$filename = OA_Delivery_Cache_buildFileName($name, $isHash);
$aCacheVar = OX_Delivery_Common_hook(
'cacheRetrieve',
array($filename),
$GLOBALS['_MAX']['CONF']['delivery']['cacheStorePlugin']
);
if ($aCacheVar !== false) {
if ($aCacheVar['cache_name'] != $name) {
return false;
}
// The method used to implement cache expiry imposes two cache writes if the cache is
// expired and the database is available, but avoid the need to check for file existence
// and modification time.
if ($expiryTime === null) {
$expiryTime = $GLOBALS['OA_Delivery_Cache']['expiry'];
}
$now = MAX_commonGetTimeNow();
if (    (isset($aCacheVar['cache_time']) && $aCacheVar['cache_time'] + $expiryTime < $now)
|| (isset($aCacheVar['cache_expire']) && $aCacheVar['cache_expire'] < $now) )
{
// Update expiry, needed to enable permanent caching if needed
OA_Delivery_Cache_store($name, $aCacheVar['cache_contents'], $isHash);
return false;
}
return $aCacheVar['cache_contents'];
}
return false;
}
function OA_Delivery_Cache_store($name, $cache, $isHash = false, $expireAt = null)
{
if ($cache === OA_DELIVERY_CACHE_FUNCTION_ERROR) {
// Don't store the result to enable permanent caching
return false;
}
$filename = OA_Delivery_Cache_buildFileName($name, $isHash);
$aCacheVar = array();
$aCacheVar['cache_contents'] = $cache;
$aCacheVar['cache_name'] = $name;
$aCacheVar['cache_time'] = MAX_commonGetTimeNow();
$aCacheVar['cache_expire'] = $expireAt;
return OX_Delivery_Common_hook(
'cacheStore',
array($filename, $aCacheVar),
$GLOBALS['_MAX']['CONF']['delivery']['cacheStorePlugin']
);
}
function OA_Delivery_Cache_store_return($name, $cache, $isHash = false, $expireAt = null)
{
OX_Delivery_Common_hook(
'preCacheStore_'.OA_Delivery_Cache_getHookName($name),
array($name, &$cache)
);
if (OA_Delivery_Cache_store($name, $cache, $isHash, $expireAt)) {
return $cache;
}
$currentCache = OA_Delivery_Cache_fetch($name, $isHash);
// If cache storage is unavailable return given cache
if ($currentCache === false) {
return $cache;
}
return $currentCache;
}
function OA_Delivery_Cache_getHookName($name)
{
$pos = strpos($name, '^');
return $pos ? substr($name, 0, $pos) : substr($name, 0, strpos($name, '@'));
}
function OA_Delivery_Cache_buildFileName($name, $isHash = false)
{
if(!$isHash) {
// If not a hash yet
$name = md5($name);
}
return $GLOBALS['OA_Delivery_Cache']['prefix'].$name.'.php';
}
function OA_Delivery_Cache_getName($functionName)
{
$args = func_get_args();
$args[0] = strtolower(str_replace('MAX_cacheGet', '', $args[0]));
return join('^', $args).'@'.$GLOBALS['OA_Delivery_Cache']['host'];
}
function MAX_cacheGetAd($ad_id, $cached = true)
{
$sName  = OA_Delivery_Cache_getName(__FUNCTION__, $ad_id);
if (!$cached || ($aRows = OA_Delivery_Cache_fetch($sName)) === false) {
MAX_Dal_Delivery_Include();
$aRows = OA_Dal_Delivery_getAd($ad_id);
$aRows = OA_Delivery_Cache_store_return($sName, $aRows);
}
return $aRows;
}
function MAX_cacheGetAccountTZs($cached = true)
{
$sName  = OA_Delivery_Cache_getName(__FUNCTION__);
if (!$cached || ($aResult = OA_Delivery_Cache_fetch($sName)) === false) {
MAX_Dal_Delivery_Include();
$aResult = OA_Dal_Delivery_getAccountTZs();
$aResult = OA_Delivery_Cache_store_return($sName, $aResult);
}
return $aResult;
}
function MAX_cacheGetZoneLinkedAds($zoneId, $cached = true)
{
$sName  = OA_Delivery_Cache_getName(__FUNCTION__, $zoneId);
if (!$cached || ($aRows = OA_Delivery_Cache_fetch($sName)) === false) {
MAX_Dal_Delivery_Include();
$aRows = OA_Dal_Delivery_getZoneLinkedAds($zoneId);
$aRows = OA_Delivery_Cache_store_return($sName, $aRows);
}
return $aRows;
}
function MAX_cacheGetZoneInfo($zoneId, $cached = true)
{
$sName  = OA_Delivery_Cache_getName(__FUNCTION__, $zoneId);
if (!$cached || ($aRows = OA_Delivery_Cache_fetch($sName)) === false) {
MAX_Dal_Delivery_Include();
$aRows = OA_Dal_Delivery_getZoneInfo($zoneId);
$aRows = OA_Delivery_Cache_store_return($sName, $aRows);
}
return $aRows;
}
function MAX_cacheGetLinkedAds($search, $campaignid, $laspart, $cached = true)
{
$sName  = OA_Delivery_Cache_getName(__FUNCTION__, $search, $campaignid, $laspart);
if (!$cached || ($aAds = OA_Delivery_Cache_fetch($sName)) === false) {
MAX_Dal_Delivery_Include();
$aAds = OA_Dal_Delivery_getLinkedAds($search, $campaignid, $laspart);
$aAds = OA_Delivery_Cache_store_return($sName, $aAds);
}
return $aAds;
}
function MAX_cacheGetCreative($filename, $cached = true)
{
$sName  = OA_Delivery_Cache_getName(__FUNCTION__, $filename);
if (!$cached || ($aCreative = OA_Delivery_Cache_fetch($sName)) === false) {
MAX_Dal_Delivery_Include();
$aCreative = OA_Dal_Delivery_getCreative($filename);
$aCreative['contents'] = addslashes(serialize($aCreative['contents']));
$aCreative = OA_Delivery_Cache_store_return($sName, $aCreative);
}
$aCreative['contents'] = unserialize(stripslashes($aCreative['contents']));
return $aCreative;
}
function MAX_cacheGetTracker($trackerid, $cached = true)
{
$sName  = OA_Delivery_Cache_getName(__FUNCTION__, $trackerid);
if (!$cached || ($aTracker = OA_Delivery_Cache_fetch($sName)) === false) {
MAX_Dal_Delivery_Include();
$aTracker = OA_Dal_Delivery_getTracker($trackerid);
$aTracker = OA_Delivery_Cache_store_return($sName, $aTracker);
}
return $aTracker;
}
function MAX_cacheGetTrackerLinkedCreatives($trackerid = null, $cached = true)
{
$sName  = OA_Delivery_Cache_getName(__FUNCTION__, $trackerid);
if (!$cached || ($aTracker = OA_Delivery_Cache_fetch($sName)) === false) {
MAX_Dal_Delivery_Include();
$aTracker = OA_Dal_Delivery_getTrackerLinkedCreatives($trackerid);
$aTracker = OA_Delivery_Cache_store_return($sName, $aTracker, $isHash = true);
}
return $aTracker;
}
function MAX_cacheGetTrackerVariables($trackerid, $cached = true)
{
$sName  = OA_Delivery_Cache_getName(__FUNCTION__, $trackerid);
if (!$cached || ($aVariables = OA_Delivery_Cache_fetch($sName)) === false) {
MAX_Dal_Delivery_Include();
$aVariables = OA_Dal_Delivery_getTrackerVariables($trackerid);
$aVariables = OA_Delivery_Cache_store_return($sName, $aVariables);
}
return $aVariables;
}
function MAX_cacheCheckIfMaintenanceShouldRun($cached = true)
{
// Default delay is 5 minutes
$interval    = $GLOBALS['_MAX']['CONF']['maintenance']['operationInterval'] * 60;
$delay       = !empty($GLOBALS['_MAX']['CONF']['maintenance']['autoMaintenanceDelay']) ?
$GLOBALS['_MAX']['CONF']['maintenance']['autoMaintenanceDelay'] * 60 :
300;
// Auto-maintenance is disabled if the delay is lower than the OI
if ($delay <= 0 || $delay >= $interval) {
return false;
}
$now         = MAX_commonGetTimeNow();
$today       = strtotime(date('Y-m-d'), $now);
$nextRunTime = $today + (floor(($now - $today) / $interval) + 1) * $interval + $delay;
// Adding the delay could shift the time to the next operation interval,
// make sure to fix it in case it happens
if ($nextRunTime - $now > $interval) {
$nextRunTime -= $interval;
}
$cName  = OA_Delivery_Cache_getName(__FUNCTION__);
if (!$cached || ($lastRunTime = OA_Delivery_Cache_fetch($cName)) === false) {
MAX_Dal_Delivery_Include();
$lastRunTime = OA_Dal_Delivery_getMaintenanceInfo();
// Cache until the next operation interval if scheduled maintenance was run
// during the delay
if ($lastRunTime >= $nextRunTime - $delay) {
$nextRunTime += $interval;
}
OA_Delivery_Cache_store($cName, $lastRunTime, false, $nextRunTime);
}
return $lastRunTime < $nextRunTime - $interval;
}
function MAX_cacheGetChannelLimitations($channelid, $cached = true)
{
$sName  = OA_Delivery_Cache_getName(__FUNCTION__, $channelid);
if (!$cached || ($limitations = OA_Delivery_Cache_fetch($sName)) === false) {
MAX_Dal_Delivery_Include();
$limitations = OA_Dal_Delivery_getChannelLimitations($channelid);
$limitations = OA_Delivery_Cache_store_return($sName, $limitations);
}
return $limitations;
}
function MAX_cacheGetGoogleJavaScript($cached = true)
{
$sName  = OA_Delivery_Cache_getName(__FUNCTION__);
if (!$cached || ($output = OA_Delivery_Cache_fetch($sName)) === false) {
$file = '/lib/max/Delivery/google.php';
if(!isset($GLOBALS['_MAX']['FILES'][$file])) {
include MAX_PATH . $file;
}
$output = MAX_googleGetJavaScript();
$output = OA_Delivery_Cache_store_return($sName, $output);
}
return $output;
}
function OA_cacheGetPublisherZones($affiliateid, $cached = true)
{
$sName  = OA_Delivery_Cache_getName(__FUNCTION__, $affiliateid);
if (!$cached || ($output = OA_Delivery_Cache_fetch($sName)) === false) {
MAX_Dal_Delivery_Include();
$output = OA_Dal_Delivery_getPublisherZones($affiliateid);
$output = OA_Delivery_Cache_store_return($sName, $output);
}
return $output;
}
// Set the viewer's remote information used in logging
// and delivery limitation evaluation
MAX_remotehostSetInfo();
// Set common delivery parameters in the global scope
MAX_commonInitVariables();
// Load cookie data from client/plugin
MAX_cookieLoad();
// Unpack the packed capping cookies
MAX_cookieUnpackCapping();
// Required files
function MAX_querystringConvertParams()
{
$conf = $GLOBALS['_MAX']['CONF'];
$qs = $_SERVER['QUERY_STRING'];
// 1.  Strip off the destination
$dest = false;
$destStr = $conf['var']['dest'] . '=';
$pos = strpos($qs, $destStr);
if ($pos === false) {
$destStr = 'dest=';
$pos = strpos($qs, $destStr);
}
if ($pos !== false) {
$dest = urldecode(substr($qs, $pos + strlen($destStr)));
$qs = substr($qs, 0, $pos);
}
// 2.  Parse the remaining string
$aGet = array();
$paramStr = $conf['var']['params'] . '=';
$paramPos = strpos($qs, $paramStr);
if (is_numeric($paramPos)) {
$qs = urldecode(substr($qs, $paramPos + strlen($paramStr)));
$delim = $qs{0};
if (is_numeric($delim)) {
$delim = substr($qs, 1, $delim);
}
$qs = substr($qs, strlen($delim) + 1);
MAX_querystringParseStr($qs, $aGet, $delim);
// Fix the destination URL since if appended by a form, it will have no '?'
$qPos = isset($aGet[$conf['var']['dest']]) ? strpos($aGet[$conf['var']['dest']], '?') : false;
$aPos = isset($aGet[$conf['var']['dest']]) ? strpos($aGet[$conf['var']['dest']], '&') : false;
if ($aPos && !$qPos) {
$desturl = substr($aGet[$conf['var']['dest']], 0, $aPos);
$destparams = substr($aGet[$conf['var']['dest']], $aPos+1);
$aGet[$conf['var']['dest']] = $desturl . '?' . $destparams;
}
} else {
parse_str($qs, $aGet);
}
if ($dest !== false) {
$aGet[$conf['var']['dest']] = $dest;
}
// 3.  Add any cookie values to the GET string...
$n = isset($_GET[$conf['var']['n']]) ? $_GET[$conf['var']['n']] : '';
if (empty($n)) {
// Try from querystring
$n = isset($aGet[$conf['var']['n']]) ? $aGet[$conf['var']['n']] : '';
}
if (!empty($n) && !empty($_COOKIE[$conf['var']['vars']][$n])) {
$aVars = unserialize(stripslashes($_COOKIE[$conf['var']['vars']][$n]));
foreach ($aVars as $name => $value) {
if (!isset($_GET[$name])) {
$aGet[$name] = $value;
}
}
}
$_GET = $aGet;
$_REQUEST = $_GET + $_POST + $_COOKIE;
}
function MAX_querystringGetDestinationUrl($adId = null)
{
$conf = $GLOBALS['_MAX']['CONF'];
$dest = isset($_REQUEST[$conf['var']['dest']]) ? $_REQUEST[$conf['var']['dest']] : '';
if (empty($dest) && !empty($adId)) {
// Get the destination from the banner
$aAd = MAX_cacheGetAd($adId);
if (!empty($aAd)) {
$dest = $aAd['url'];
}
}
// If no destination URL has been found by now, then we don't need to redirect
if (empty($dest)) {
return;
}
//if (empty($dest)) {
//    $dest = ($adId == 'DEFAULT') ? $pref['default_banner_destination'] : $_SERVER['HTTP_REFERER'];
//}
$aVariables = array();
$aValidVariables = array(
$conf['var']['adId'],
$conf['var']['cacheBuster'],
$conf['var']['channel'],
$conf['var']['dest'],
$conf['var']['logClick'],
$conf['var']['n'],
$conf['var']['zoneId'],
$conf['var']['params'],
$conf['var']['cookieTest'],
$conf['var']['lastClick'],
'channel_ids'
);
// We also need to ensure that any variables already present in the dest are not duplicated...
$destParams = parse_url($dest);
if (!empty($destParams['query'])) {
$destQuery = explode('&', $destParams['query']);
if (!empty($destQuery)) {
foreach ($destQuery as $destPair) {
list($destName, $destValue) = explode('=', $destPair);
$aValidVariables[] = $destName;
}
}
}
foreach ($_GET as $name => $value) {
if (!in_array($name, $aValidVariables)) {
$aVariables[] = $name . '=' . $value;
}
}
foreach ($_POST as $name => $value) {
if (!in_array($name, $aValidVariables)) {
$aVariables[] = $name . '=' . $value;
}
}
if (!empty($aVariables)) {
$dest .= ((strpos($dest, '?') > 0) ? '&' : '?') . implode('&', $aVariables);
}
return $dest;
}
function MAX_querystringParseStr($qs, &$aArr, $delim = '&')
{
$aArr = $_GET;
// Parse the rest of the array and add to the request array.
$aElements = explode($delim, $qs);
foreach($aElements as $element) {
$len = strpos($element, '=');
if ($len !== false) {
$name = substr($element, 0, $len);
$value = substr($element, $len+1);
$aArr[$name] = urldecode($value);
}
}
}
// Prevent the logging beacon from being cached by browsers
MAX_commonSetNoCacheHeaders();
// Remove any special characters from the request variables
MAX_commonRemoveSpecialChars($_REQUEST);
// Get the viewer ID, and the ad, campaign, creative and zone variables to be logged
// from the request variables
$viewerId     = MAX_cookieGetUniqueViewerId();
MAX_cookieAdd($conf['var']['viewerId'], $viewerId, _getTimeYearFromNow());
$aAdIds       = MAX_Delivery_log_getArrGetVariable('adId');
$aCampaignIds = MAX_Delivery_log_getArrGetVariable('campaignId');
$aCreativeIds = MAX_Delivery_log_getArrGetVariable('creativeId');
$aZoneIds     = MAX_Delivery_log_getArrGetVariable('zoneId');
// Get any ad, campaign and zone capping information from the request variables
$aCapAd['block']                 = MAX_Delivery_log_getArrGetVariable('blockAd');
$aCapAd['capping']               = MAX_Delivery_log_getArrGetVariable('capAd');
$aCapAd['session_capping']       = MAX_Delivery_log_getArrGetVariable('sessionCapAd');
$aCapCampaign['block']           = MAX_Delivery_log_getArrGetVariable('blockCampaign');
$aCapCampaign['capping']         = MAX_Delivery_log_getArrGetVariable('capCampaign');
$aCapCampaign['session_capping'] = MAX_Delivery_log_getArrGetVariable('sessionCapCampaign');
$aCapZone['block']               = MAX_Delivery_log_getArrGetVariable('blockZone');
$aCapZone['capping']             = MAX_Delivery_log_getArrGetVariable('capZone');
$aCapZone['session_capping']     = MAX_Delivery_log_getArrGetVariable('sessionCapZone');
$aSetLastSeen                    = MAX_Delivery_log_getArrGetVariable('lastView');
if (isset($_REQUEST['channel_ids'])) {
$GLOBALS['_MAX']['CHANNELS'] = str_replace(
$GLOBALS['_MAX']['CONF']['delivery']['chDelimiter'],
$GLOBALS['_MAX']['MAX_DELIVERY_MULTIPLE_DELIMITER'],
$_REQUEST['channel_ids']
);
}
// Loop over the ads to be logged (there may be more than one due to internal re-directs)
// and log each ad, and th  en set any capping cookies required
$countAdIds = count($aAdIds);
for ($index = 0; $index < $countAdIds; $index++) {
// Ensure that each ad to be logged has campaign, creative and zone
// values set, and that all values are integers
MAX_Delivery_log_ensureIntegerSet($aAdIds, $index);
MAX_Delivery_log_ensureIntegerSet($aCampaignIds, $index);
MAX_Delivery_log_ensureIntegerSet($aCreativeIds, $index);
MAX_Delivery_log_ensureIntegerSet($aZoneIds, $index);
if ($aAdIds[$index] >= -1) {
$adId = $aAdIds[$index];
// Log the ad impression, if required
if ($GLOBALS['_MAX']['CONF']['logging']['adImpressions']) {
MAX_Delivery_log_logAdImpression($adId, $aZoneIds[$index]);
}
if ($aAdIds[$index] == $adId) {
// Set the capping cookies, if required
MAX_Delivery_log_setAdLimitations($index, $aAdIds, $aCapAd);
MAX_Delivery_log_setCampaignLimitations($index, $aCampaignIds, $aCapCampaign);
MAX_Delivery_log_setLastAction($index, $aAdIds, $aZoneIds, $aSetLastSeen);
if ($aZoneIds[$index] != 0) {
MAX_Delivery_log_setZoneLimitations($index, $aZoneIds, $aCapZone);
}
}
}
}
MAX_cookieFlush();
MAX_querystringConvertParams();
if (!empty($_REQUEST[$GLOBALS['_MAX']['CONF']['var']['dest']])) {
MAX_redirect($_REQUEST[$GLOBALS['_MAX']['CONF']['var']['dest']]);
} else {
// Display a 1x1 pixel gif
MAX_commonDisplay1x1();
}
// Run automaintenance, if needed
if (!empty($GLOBALS['_MAX']['CONF']['maintenance']['autoMaintenance']) && empty($GLOBALS['_MAX']['CONF']['lb']['enabled'])) {
if (MAX_cacheCheckIfMaintenanceShouldRun()) {
include MAX_PATH . '/lib/OA/Maintenance/Auto.php';
OA_Maintenance_Auto::run();
}
}


?>